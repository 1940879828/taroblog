---
title: 区块链的运作机制
date: 2024-08-31 11:55:56
tags: 'Web3'
categories: 'Web3'
cover: http://qny.bioart.icu/blog/202408311542165.png
---

### 哈希算法的概念

了解运作机制之前要先了解哈希算法



哈希算法它是一种单向密码体制，即它是一个从明文到密文的不可逆的映射，只有加密过程，没有解密过程。一般把哈希算法得出来的结果称为哈希Hash



哈希Hash是一个独一无二的固定长度字符串，用来代表一段数据，它通过将一个数据传入"哈希函数"来生成。生成哈希的函数有很多种，比如常见的SHA256，以太坊使用的是Keccak256算法

### 区块的矿工的作用

区块的示例网站：[Blockchain Demo (andersbrownworth.com)](https://andersbrownworth.com/blockchain/block)

![image-20240831154232099](http://qny.bioart.icu/blog/202408311542165.png)

在区块中我们把数据分块

- Block 区块
- Nonce 随机数
- Data 数据：在实际BTC系统里，Data域就是body，里面有交易树结构

我们会把这3部分都进行哈希运算，得到哈希值。



而“矿工”的工作其实是解题，一道填空题，挖矿的时候，矿工会收到一道题目，图中的区块和数据是固定的而哈希是目标，随机数是答案。因为哈希是单向的，你只能通过穷举去穷举随机数Nonce的值，穷举到了这个随机数，也就是72608后，发现哈希值与目标哈希一致，那么这道题就解出来了，答案是72608。



这就是矿工的作用，不断计算找到Nonce，而这个Nonce可以解决对于的 “难题”，在这里是Hash。而解题其实是靠“碰运气的”。

> Hash开头的0越多，找到解的概率越小，挖矿难度越大。
>
> 这是因为哈希函数的输出是均匀分布的，也就是说在所有可能的哈希值中，任何特定的输出值（如以0开头）出现的概率是极低的。

### 区块链

在上面的例子我们能理解单独区块，如果有很多个区块呢？

区块链的示例网站：[Blockchain Demo (andersbrownworth.com)](https://andersbrownworth.com/blockchain/blockchain)

![image-20240831155610678](http://qny.bioart.icu/blog/202408311556780.png)

在区块链中多了属性 前指针 Prev:

- Prev 前指针：指向上一个区块的哈希值



观察图中的Prev可以发现，区块3的前指针指向区块2的哈希，区块2的前指针指向区块1的哈希，而第一个区块1的前指针则全为0，像一个链表一样，这就是区块链。



第一个区块也被称为创世区块（Genesis Block），也就是区块链中的第一个区块，它的Prev指向一个不存在的区块。



而在区块链中Hash计算时要的输入要包含前指针Prev，也就是说，要是你改变了区块2的Data，那么区块2后面的所有区块都会变红，意味着他们都无效了



这就是区块链实现“无法篡改”的方式。只要你改了一个区块上的内容，会让后面的区块都无效。



当然你可以重新从修改的区块开始计算，然后把后面的都挖或者说计算出来，但是挖这些区块需要很大的计算量，因为需要重新挖整个区块链的区块，你修改的区块越靠前，重新哈希运算的难度就越大。所以说区块链的历史数据很难被篡改。但还是会有被重新挖的可能，不是吗？那这里就是去中心化或者说分布式的特性发挥作用的时候了。

### 分布式

分布式的示例网站：[Blockchain Demo (andersbrownworth.com)](https://andersbrownworth.com/blockchain/distributed)

![image-20240831160928118](http://qny.bioart.icu/blog/202408311609197.png)

可以看到我们现在有很多个节点（Peer），很多人提到的P2P就是这里的Peer的概念，不同的节点（Peer）都在运行这个区块链，他们的权重相同，区块链中的每一个Peer，节点或者说运营主体都有这相同的权力，决定那条链才是正确的链的方法非常简单



那就是比较最后一个哈希值，因为哈希运算是“单向的”，最后一个区块的哈希值依赖上一个区块，所以最后一个区块的哈希值，包含了前面所有区块的信息。



现在如果你想对区块链历史动手脚重新挖矿，计算到最后一个哈希的数据，比如修改Peer A的数据，最后一个区块的数据与Peer B和Peer C必定不一样，那Peer A实际上分叉出了一条区块链，记录它自己的历史数据。



在分布式中每个人都是监督者，而这里又能牵扯到最长链有效原则，其他节点不需要重头开始挖矿，接着合法链继续往后挖即可。



这就绝对安全了吗？也不是，在这个3节点的网络中，只要Peer A 说服另外2个中的一个Peer，跟他一起修改历史数据并重新挖矿（这就是代价），那么最后会发生什么，少数服从多数，这种情况下Peer A的阴谋诡计就成功了，真的修改了历史的数据。也就是大家说的区块链的51%攻击，只要大于50%的链历史被修改，那假的也会变成真的（人多力量大（雾）），但是假如你都有51%的节点权力了，那你为什么要捣乱。



在真实链中Data部分存储的是交易信息，捣乱就是为了搞钱嘛，都能动用51%的节点了，还会缺钱（Ps：也说不准吼）？毕竟重新算51%成本也是非常高的。

>  Data替换为交易信息的示例： [Blockchain Demo (andersbrownworth.com)](https://andersbrownworth.com/blockchain/tokens)



当然这只是一个示例，区块链其实是通过Solidity代码运行的，而非将随机值放在Data区域，Solidity代码定义了链上不同区块和协议交互方式，实际挖矿的时候难度也要大得多, Hash前面至少10几个零



#### 关于哈希碰撞

我们知道哈希是单向计算的，固定的字符压缩经过算法得到固定的哈希，有没有可能出现像`md5彩虹表`的情况呢，就是说我输入的数据不一样，但是哈希函数返回的哈希值是一样的，这种想要人为的进行哈希碰撞的想法，以现在的技术，几乎不可能实现。

> **碰撞代表特殊性**：哈希碰撞代表着多个输入映射到同一个输出，这是在极高熵的系统中形成的一种有序状态。然而，这种有序状态非常罕见，因为理想的哈希函数旨在最大化熵，使得输出尽可能随机。
>
> **概率极低**：由于哈希函数的输出空间非常大（例如，SHA-256的输出空间有 2的256次方 种可能性），在这个巨大的空间中，随便选取两个输入而产生相同哈希值的概率极低。要想通过人为的方法刻意找到两个不同的输入导致相同的哈希值，所需的计算量和尝试次数是天文数字。
>
> 哈希碰撞作为一种熵减行为，意味着系统从高熵、高随机性状态转向一个极其低概率的有序状态。由于现代哈希函数的设计旨在最大化熵和抗碰撞性，试图通过人为干预来制造碰撞所需的计算资源和时间代价巨大，几乎不可能实现。因此，在实际应用中，哈希碰撞极难人为制造。



你可能会问个问题，怎么确定交易确实是由某个人发出的，这里我们就需要了解公钥和私钥等关于签名交易（Signing Transactions）的内容

